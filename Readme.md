<h1 align="center"><b> Сервис перевода денег </b> </h1>

<p align="center">

<img src="https://img.shields.io/badge/made-Madmaxim22-blue">
<img src="https://img.shields.io/badge/JDK-17-blue">
<img src="https://img.shields.io/github/stars/Madmaxim22/MoneyTransferService?color=yellow">
<img src="https://img.shields.io/github/forks/Madmaxim22/MoneyTransferService?color=blue">
<img src="https://img.shields.io/github/watchers/Madmaxim22/MoneyTransferService?color=blue">
<img src="https://img.shields.io/github/downloads/Madmaxim22/MoneyTransferService/total?color=blue">
</p>

<h2 align="center"><b>Описание проекта</b></h2>

Приложение для перевода денег с одной карты на другую, разработанное с использованием Spring Boot. 

Проект перевода денег реализован с использованием трехслойной архитектуры.
<details>
<summary> Трёху́ровневая архитекту́ра </summary>

``Трёху́ровневая архитекту́ра`` (трёхзве́нная архитекту́ра, англ. three-tier) — архитектурная модель программного комплекса,
предполагающая наличие в нём трёх типов компонентов (уровней, звеньев): клиентских приложений (с которыми работают
пользователи), серверов приложений (с которыми работают клиентские приложения) и серверов баз данных (с которыми работают
серверы приложений)

![Трёху́ровневая архитекту́ра](src%2Fmain%2Fresources%2FImage%2FCSD_SCHEME.png)

Архитектура шаблона состоит из трех уровней:

- **Слой клиента**: это часть «распределенного приложения», которая отвечает за взаимодействие с пользователем. Этот слой 
    не должен содержать бизнес-логики и не должен хранить критически важные данные. Также он не должен взаимодействовать со 
    слоем базы данных напрямую, а только через слой бизнес-логики.

- **Слой бизнес-логики**: располагается на втором уровне, на нем сосредоточена бо́льшая часть бизнес-логики. Вне его остаются 
    только фрагменты, экспортируемые на клиента, а также элементы логики, погруженные в базу данных (хранимые процедуры и триггеры).

- **Слой данных**: обеспечивает хранение данных и выносится на отдельный уровень, реализуется, как правило, средствами
  систем управления базами данных (СУБД), подключение к этому компоненту обеспечивается только с уровня сервера приложений.


<h3 align="center">Преимущества</h3>

По сравнению с двухзвенной клиент-серверной архитектурой или файл-серверной архитектурой трёхуровневая архитектура обеспечивает, 
как правило, бо́льшую масштабируемость (за счёт горизонтальной масштабируемости сервера приложений и мультиплексирования соединений), 
бо́льшую конфигурируемость (за счёт изолированности уровней друг от друга). Реализация приложений, доступных из веб-браузера или из 
тонкого клиента, как правило, подразумевает развёртывание программного комплекса в трёхуровневой архитектуре. При этом обычно разработка 
трёхзвенных программных комплексов сложнее, чем для двухзвенных, также наличие дополнительного связующего программного обеспечения может 
налагать дополнительные издержки в администрировании таких комплексов.

</details>

<h2 align="center"><b>Как установить и запустить проект</b></h2>

Для запуска приложения необходимо:
- установить Docker Compose;
- сделать git pull приложения;
- перейти в корневую папку приложения;
- собрать проект выполнив команду **docker-compose build**;
- выполнить команду **docker compose up -d**
- перейти по адресу http://localhost:3000/

<h2 align="center"><b>Справочно</b></h2>

- структура проекта схематично отображена в директории documentation;  
- ТЗ проекта представлено в директории documentation;  
- файлы системных логов записываются:   
  - В Windows тома находятся по умолчанию в **\\wsl.localhost\docker-desktop-data\data\docker\volumes\moneytransferservice_logs_app\_data**;  
  - В Linux тома находятся по умолчанию в **/var/lib/docker/volumes/**;  
- по умолчанию сервер запускается на порту 8080;  
- процесс обмена backend'ом и frontend'ом описан в MoneyTransferServiceSpecification.yaml.   
 

<h2 align="center"><b> Научился </b></h2>

1. Создавать REST-приложение;
2. Использовать библиотеку валидации jakarta.validation.Valid;
3. Обрабатывать Json объекты с использованием аннотаций;
4. Использовать @CrossOrigin аннотацию для совместного использования ресурсов между разными источниками;
5. Преобразовывать разные объекты модели с использованием библиотеки org.mapstruct;
6. Настройка логирования(разделение по уровням логирования, логирование в файл и в консоль) с использованием Logback;
7. Интеграционное тестирование приложения на уровне представления с использованием MockMvc;
8. Интеграционное тестирование с использованием аннотации @Testcontainers;
9. Создание Dockerfile для backend'а и frontend'а;
10. Создание композиции с помощью docker-compose.yaml;
11. Использование томов для сохранения лог фалов приложения;
